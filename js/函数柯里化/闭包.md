# 闭包

```jsx
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  return bar;
}
var baz = foo();
baz(); //2   ->朋友，这就是闭包的效果
```

- 闭包是发生在定义的时候，实际上和是否调用无关。即使外部函数已经执行完毕，但是内部函数仍然可以访问外部函数的变量。
- 只要是内部函数访问了外部函数的变量，那这个外部函数的变量会被存储在内存中，即便外部函数已经执行完毕。

## 什么是闭包（形成闭包的两个关键点）

- 内部函数可以访问其外部作用域的变量。
- 内部函数必须要**暴露**到外部作用域，这就意味着你必须返回这个函数或者通过其他的方法让内部函数可以在外部作用域中被访问。

### 暴露到外部的方法

- 回调函数

```jsx
function outer() {
  let count = 0;
  setInterval(function inner() {
    // 这里 inner 是通过回调暴露的
    count++;
    console.log(count);
  }, 1000);
}

outer(); // 每秒输出 count 的值，形成闭包
```

- 事件监听函数
- return 函数
- 利用全局变量把内部函数传出来

```jsx
//利用全局变量把闭包传出来
var fn;
function foo() {
  var a = 2;
  function baz() {
    console.log(a);
  }
  fn = baz;
}
function bar() {
  fn();
}
foo();
bar();
```

## 闭包的精髓

- 作用域链
  每个 JavaScript 函数都有一个 **词法作用域**，这就是函数能够访问的变量范围。闭包的产生依赖于作用域链的概念，它允许内部函数访问外部函数的变量和参数。  
  当一个函数在其外部作用域中定义时（比如嵌套函数），该内部函数会 “记住” 外部函数的作用域，形成一个作用域链，即使外部函数已经执行完毕，内部函数仍然能够访问外部函数的变量。
  - 比如说 bar 他的词法作用域就是 foo 的作用域，所以 bar 可以访问 foo 的变量 a。
- 持久化引用
  闭包的另一个关键特性是 持久化外部变量的引用。通常，在函数执行完毕后，外部函数的局部变量会被销毁，但是通过闭包，内部函数对外部变量的引用会被保留下来。这就允许外部函数的变量在外部函数执行完后依然存在于内存中，直到闭包被销毁。

## 缺点

- 容易造成内存泄漏，该销毁的没销毁
- 性能问题
