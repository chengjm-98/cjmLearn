# 防抖节流

## 1. 防抖（Debounce）

防抖的核心思想是：在事件被触发后，等待一段时间，如果在这段时间内事件没有再次触发，那么执行事件处理函数。如果在这段时间内再次触发事件，则重新计时。通常用于处理连续的输入或搜索框的输入事件。

**防抖的应用场景：**

- 输入框实时搜索（搜索时用户输入一个字母后停顿几百毫秒再发送请求）。
- 按钮点击的防重复提交。
- 监听窗口大小变化的防抖。

### **说人话**

也就是说，当事件被触发后先不急着执行处理函数，而是等待一段时间，如果这段时间内事件再次被触发，则重新计时，直到这段时间内事件不再被触发，才执行处理函数。

```jsx
实现防抖的代码：

function debounce(func, delay) {
  let timer;
  return function (...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}
----应用场景
const searchInput = document.querySelector('#search');

searchInput.addEventListener('input', debounce(function () {
  console.log('Searching for:', searchInput.value);
}, 500));

```

### 代码解释

- --this
  这里的 this 是为了让 fun 指向调用 debounce 的对象，即 searchInput 对象。
  如果你的 fun 中没有使用到 this，那么直接 func()也可以。
- --关于 args
  当 input 事件触发时，debounce 返回的函数会被调用。此时，args 会是事件对象，即 input 事件的参数。
  args 的值：由于事件回调函数被 debounce 包装，因此 args 会包含由 input 事件传递给事件处理器的参数，在这个情况下就是 event 对象。
- **args 是什么**
  args 实际上是 input 事件触发时传递给 debounce 返回函数的所有参数。在这个例子中，input 事件会触发一个 event 对象，并且该对象会作为参数传递给 debounce 函数的内部函数。
  事件对象的结构
- event 对象包含了关于事件的详细信息。例如：
- event.target：触发事件的元素（在这个例子中是 #search 输入框）。
- event.type：事件的类型（这里是 'input'）。
- 其他与事件相关的信息，如按键代码、鼠标坐标等。

## 2. 节流（Throttle）

节流的核心思想是：在规定时间间隔内，只执行一次事件处理函数。即使事件频繁触发，也不会频繁执行回调函数。节流一般用于处理滚动、resize、拖拽等高频事件。

**节流的应用场景：**

- 滚动条滚动事件。
- 按钮频繁点击时，限制点击频率。
- 页面滚动或元素拖动时，避免过度触发处理函数。

### **说人话**

就是说在一段时间内，无论事件被触发多少次，处理函数只会被执行一次。但是在这段时间内一定会执行一次处理函数。

```jsx
实现节流的代码：
function throttle(func, delay) {
  let lastTime = 0;
  return function (...args) {
    const now = new Date().getTime();
    if (now - lastTime >= delay) {
      func.apply(this, args);
      lastTime = now;
    }
  };
}
```
