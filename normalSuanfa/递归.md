# 递归的基本构成

## 递归基准条件（Base Case）：

- 递归基准条件是递归结束的条件。当满足这个条件时，递归不再继续调用自身，防止无限递归。

## 递归步骤（Recursive Step）：

- 将问题分解为子问题，并递归调用这些子问题。

# 递归的工作原理

- 递归函数通过调用自身来分解问题。
- 每次递归调用都会进入一个新的函数调用栈。
- 每个递归调用都保存当前状态，直到基准条件满足时，递归会返回，并按调用顺序逐步返回结果。

# 经典问题

## 阶乘

- 阶乘是一个经典的递归问题，它可以用以下递归公式表示：
- 阶乘的递归实现：

```js
function factorial(n) {
  // 基准条件：当 n 为 0 或 1 时，阶乘为 1
  if (n === 0 || n === 1) {
    return 1;
  }
  // 递归步骤：n 的阶乘等于 n 乘以 (n-1) 的阶乘
  return n * factorial(n - 1);
}
```

## 斐波那契数列

- 斐波那契数列是一个经典的递归问题，它可以用以下递归公式表示：
- 斐波那契数列的递归实现：
- 假设有一对兔子，出生时它们是雌雄配对的，且每一对兔子每月都会生一对兔子，并且兔子从第二个月开始可以生兔子。问：第 n 个月时，兔子对的数量是多少？

```js
function fibonacci(n) {
  // 基准条件：当 n 为 0 或 1 时，斐波那契数为 n
  if (n === 0 || n === 1) {
    return n;
  }
  // 递归步骤：斐波那契数等于前两个数的和
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

## 回文字符串

判断一个字符串是否是回文字符串（即正着读和倒着读都一样），是一个典型的递归问题。

```js
function isPalindrome(str) {
  if (str.length <= 1) return true;
  if (str[0] !== str[str.length - 1]) return false;
  return isPalindrome(str.slice(1, str.length - 1)); // 递归
}

console.log(isPalindrome("racecar")); // 输出 true
console.log(isPalindrome("hello")); // 输出 false
```

## 爬楼梯问题

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```js
function climbStairs(n) {
  if (n <= 2) return n;
  return climbStairs(n - 1) + climbStairs(n - 2); // 递归
}
```
