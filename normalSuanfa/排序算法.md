<!--
 * @Author: error: error: git config user.name & please set dead value or install git && error: git config user.email & please set dead value or install git & please set dead value or install git
 * @Date: 2025-12-30 14:50:22
 * @LastEditors: error: error: git config user.name & please set dead value or install git && error: git config user.email & please set dead value or install git & please set dead value or install git
 * @LastEditTime: 2026-01-19 17:14:59
 * @FilePath: /cjmLearn/normalSuanfa/排序算法.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->

# 1. 冒泡排序（Bubble Sort）

## 原理

冒泡排序是一种简单的排序算法，通过重复地遍历待排序的列表，比较相邻元素并交换顺序不正确的元素。每一轮遍历都会将未排序的最大元素“冒泡”到列表的末端。

## 时间复杂度

- 最优：O(n)（当数组已经是有序的）
- 平均：O(n²)
- 最坏：O(n²)

## 空间复杂度

选择排序的空间复杂度为 O(1)，因为它只需要一个额外的变量来存储最小元素的索引。

## 代码实现

```javascript
function bubbleSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    let swapped = false;
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 交换
        swapped = true;
      }
    }
    if (!swapped) break; // 提前退出优化
  }
  return arr;
}
```

# 选择排序

## 原理

选择排序每一轮从待排序部分中选择最小（或最大）元素，交换到已排序部分的末尾。与冒泡排序不同的是，选择排序不需要进行相邻元素的交换，而是选择出最小的元素进行交换。

## 时间复杂度

- 最优：O(n²)
- 平均：O(n²)
- 最坏：O(n²)

## 空间复杂度

选择排序的空间复杂度为 O(1)，因为它只需要一个额外的变量来存储最小元素的索引。

## 代码实现

```javascript
function selectionSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    let minIdx = i;
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[minIdx]) {
        minIdx = j;
      }
    }
    if (minIdx !== i) {
      [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]]; // 交换
    }
  }
  return arr;
}
```

# 插入排序

## 原理

插入排序通过构建已排序部分的方式，逐步将每个元素插入到它应该在已排序部分的位置。它的核心思想是将当前元素与已排序部分的元素进行比较并插入到正确位置。

## 时间复杂度

- 最优：O(n)（当数组已经是有序的）
- 平均：O(n²)
- 最坏：O(n²)

## 空间复杂度

插入排序的空间复杂度为 O(1)，因为它只需要一个额外的变量来存储当前元素。

## 代码实现

```javascript
function insertionSort(arr) {
  let n = arr.length;
  for (let i = 1; i < n; i++) {
    let key = arr[i];
    let j = i - 1;
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j]; // 移动元素
      j--;
    }
    arr[j + 1] = key; // 插入到正确位置
  }
  return arr;
}
```

# 快速排序

## 原理

快速排序是一种分治法排序算法，它的基本思想是：通过一趟排序将待排序数据分成两部分，一部分所有数据都比另一部分的所有数据小，然后递归地对这两部分数据进行快速排序。

## 时间复杂度

- 最优：O(n log n)
- 平均：O(n log n)
- 最坏：O(n²)（当数组已接近排序时）

## 空间复杂度

快速排序的空间复杂度为 O(log n)，因为它需要递归调用栈来保存每次划分的结果。

```javascript
function quickSort(arr) {
  if (arr.length <= 1) return arr;
  let pivot = arr[arr.length - 1]; // 选取基准
  let left = [],
    right = [];

  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return [...quickSort(left), pivot, ...quickSort(right)];
}
```

# 归并排序

## 原理

归并排序是一种分治法排序算法，它的基本思想是：将待排序数据分成两部分，分别对这两部分进行排序，然后将排好序的两部分合并成一个有序序列。

## 时间复杂度

- 最优：O(n log n)
- 平均：O(n log n)
- 最坏：O(n log n)

## 空间复杂度

归并排序的空间复杂度为 O(n)，因为它需要额外的空间来存储合并后的结果。

## 代码实现

```js
function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
}

function merge(left, right) {
  let result = [],
    i = 0,
    j = 0;

  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
    }
  }

  return result.concat(left.slice(i), right.slice(j));
}
```
