# 接口 interface

## 定义

接口是对行为的抽象，而具体如何行动需要由类去实现。?  
TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。

## 可选

```js
interface SquareConfig {
  color?: string;
  width?: number;
}
```

## 只读

```js
interface Point {
    readonly x: number;
    readonly y: number;
}
```

**readonly vs const**
最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。  
🔴**说人话**  
如果你想要变量本身不可修改，就使用 const，但是 const 定义了变量，变量内部的属性还是可以修改。  
如果你想要变量的属性不可修改，就使用 readonly。

## 额外的属性检查

```js
interface objType {
  name: string;
}
function setPersonMsg(item: objType) {
  console.log("输入姓名:" + item.name);
}
setPersonMsg({ name: "cjm", age: 26 }); //会报错
```

上面这段代码会报错 Object literal may only specify known properties, and 'age' does not exist in type 'objType'.  
因为 age 不在 objType 中，age 是一个额外的属性  
你可能会争辩这个程序已经正确地类型化了，因为 width 属性是兼容的，不存在 color 属性，而且额外的 colour 属性是无意义的。

然而，TypeScript 会认为这段代码可能存在 bug。 对象字面量会被特殊对待而且会经过 🔴 **额外属性检查**，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。

**如何解决这个问题？**

1. 类型断言（不推荐，可能不由一些潜在的错误）

```js
setPersonMsg({ name: "cjm",age:26}as objType);
```

2. 使用对象传入（不会进行额外的属性检查）
   ```js
   interface objType {
     name: string;
   }
   let item = {
     name: "cjm",
     age: 26,
   };
   function setPersonMsg(item: objType) {
     console.log("输入姓名:" + item.name);
   }
   setPersonMsg(item);
   ```
3. 使用索引签名  
    如果 objType 带有上面定义的类型的 name 属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：
   ```js
   interface objType {
     name: string;
     [propName: string]: any;
   }
   ```
   **索引签名：[key: string]: T**  
   key 的类型只能是 string 或者 number 还有 symbol  
   T 是索引签名的类型
