# 做一个长列表的图片或者是 table，有什么优化方法

# 虚拟化

## 什么是虚拟化

虚拟化的核心思想是 只渲染可见区域内的元素，其他不在视口内的元素不会被渲染。这是通过动态计算元素的位置，基于滚动事件来决定哪些元素需要渲染或销毁，从而减少不必要的 DOM 操作。

## 一些库

- react-window：最常用的虚拟化库，适合长列表、表格、网格等场景。
- react-virtualized：功能更全，支持虚拟化长列表、表格、网格等，但相对较重。

## 库的使用

```jsx
import React from "react";
import { FixedSizeList as List } from "react-window";

// 假设这是长列表的图片数据
const images = Array(1000)
  .fill()
  .map((_, index) => `https://example.com/image${index}.jpg`);

const ImageList = () => {
  const renderRow = ({ index, style }) => (
    <div style={style}>
      <img
        src={images[index]}
        alt={`image-${index}`}
        style={{ width: "100%", height: "auto" }}
      />
    </div>
  );

  return (
    <List
      height={600} // 可视区域的高度
      itemCount={images.length} // 总条目数量
      itemSize={200} // 每个条目的高度
      width={800} // 可见区域的宽度
    >
      {renderRow}
    </List>
  );
};

export default ImageList;
```

# 懒加载

## 什么是懒加载

懒加载的核心思想是 只加载当前视口内可见的内容，其他内容在需要时再加载。这是通过动态加载资源（图片、脚本、样式等）来减少初始加载的资源大小，从而提高页面加载速度。
懒加载是一种按需加载的技术，只有当元素（如图片、表格行等）接近或进入视口时，才会加载该元素。这样可以显著减少页面的首屏加载时间。

## 怎么实现

- 使用 IntersectionObserver API：这是一种浏览器原生的 API，用于检测元素是否进入视口。
- 使用第三方库：如 react-lazyload、react-lazyload-image-component 等。

## 具体代码

```jsx
import React, { useState, useEffect } from "react";

const LazyImage = ({ src, alt }) => {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          setIsVisible(true); // 触发加载
          observer.disconnect(); // 停止观察
        }
      },
      { threshold: 0.1 }
    );

    const element = document.getElementById(alt);
    if (element) observer.observe(element);

    return () => observer.disconnect(); // 清理
  }, [alt]);

  return <div id={alt}>{isVisible && <img src={src} alt={alt} />}</div>;
};

const ImageList = () => {
  const images = Array(1000)
    .fill()
    .map((_, index) => `https://example.com/image${index}.jpg`);
  return (
    <div>
      {images.map((image, index) => (
        <LazyImage key={index} src={image} alt={`image-${index}`} />
      ))}
    </div>
  );
};

export default ImageList;
```

# 分页滚动配合流式加载

避免一次性加载大量数据导致浏览器卡顿。

## 实现

流式加载图片： 利用 IntersectionObserver 来逐步加载图片。

流式加载表格： 结合 分页加载 和 无限滚动 技术，通过后台接口逐步获取数据，避免一次性加载大量行数据。

接口分页加载： 对于表格等数据，通常采用分页或滚动加载接口数据。
