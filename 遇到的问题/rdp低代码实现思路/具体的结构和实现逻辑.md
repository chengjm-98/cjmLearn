# 架构

```jsx
┌───────────────┐
│ 物料区（组件库） │  ← Button / Table / Form …
└───────▲───────┘
        │ 拖拽
┌───────┴───────┐
│ 画布区 Canvas │  ← 拖放 / 排序 / 选中
└───────▲───────┘
        │ 选中
┌───────┴───────┐
│ 属性面板 Props │  ← 修改配置
└───────▲───────┘
        │ 状态同步
┌───────┴───────┐
│ 状态管理 Store │  ← 页面 Schema
└───────▲───────┘
        │ 序列化
┌───────┴───────┐
│ Schema(JSON)  │  ← 保存 / 预览 / 发布
└───────────────┘
```

- 拖拽方案
  - react-dnd 工程级、灵活、复杂
- 拖拽的本质逻辑
  - 拖拽不是“移动 DOM”，而是：
  - 拖拽 = 改变 Schema 的结构
- 本质
  - 拖拽结束向 Store 中插入一个 Node，React 重新根据 Schema render

# 物料库

## 物料库 =「组件实现」+「组件描述协议（Meta）」的集合

- 一个物料 = 两个东西
- 组件实现（React 组件）
- 组件描述协议（Meta）
- 所有组件必须 注册 才能被低代码平台使用。

## 可拖动组件

- 遍历物料库动态生成的

```jsx
Object.values(materialLibrary).map((item) => (
  <DraggableItem key={item.meta.type} meta={item.meta} />
));
```

# 拖拽过程

- Step 11️⃣ 用户开始拖拽
- Step 22️⃣ 拖拽释放在画布

```jsx
  onDragEnd(event) {
  const material = event.active.data.current
createNode(material)
}

```

- Step 33️⃣ 创建一个「页面节点 Node」

```jsx
const newNode = {
  id: generateId(),
  type: "Button",
  props: {
    text: "按钮",
    type: "primary",
  },
  children: [],
};
```

- Step 44️⃣ 插入到 Schema 中

```jsx
pageSchema = {
  id: "root",
  type: "Container",
  children: [],
};
```

# 画布渲染方案

- 把 Schema 转换成 React Element
- 通用渲染器（递归）
- 画布不会关心拖拽、属性编辑，它只关心 Schema

```jsx
function CanvasRenderer({ node }) {
  const { type, props, children } = node;

  const Component = materialLibrary[type].component;

  return (
    <EditorWrapper nodeId={node.id}>
      <Component {...props}>
        {children?.map((child) => (
          <CanvasRenderer key={child.id} node={child} />
        ))}
      </Component>
    </EditorWrapper>
  );
}
```

# 属性面板是怎么控制画布的？

- 点击画布元素
  - selectedNodeId = 'node_1'
- 属性面板根据 Meta 动态生成表单
  ```jsx
  const meta = materialLibrary[node.type].meta;
   meta.propsSchema.map(field => {
    return <FormItem ... />
    })
  ```
- 修改属性 = 修改 Schema
  - React 自动 re-render。

# 为什么这种设计可以支撑

- 扩展性
  - 新增组件 = 注册 Meta + Component
  - 无需改画布、属性面板
- 可存储 / 可还原
  - JSON 天然适合存 DB
  - 打开页面 = 重新渲染 Schema
- 可进阶
  - Schema → React 代码
  - Schema → DSL / 服务端渲染
