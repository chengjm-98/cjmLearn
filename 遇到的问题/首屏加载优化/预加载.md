# 在 html 中使用 link 预加载< preload 和 prefetch >

- preload = 当前页面马上用 优先级更高适合首屏资源 - 不阻塞渲染
- prefetch = 下一页面可能用 下一个页面可能会用到的资源 - 比如路由页面的 js/图片。- 不阻塞渲染
- 可使用范围：图片、js、css、字体、音频、视频等

```js
<link rel="preload" href="/banner.jpg" as="image">
<link rel="preload" href="/static/js/main.js" as="script">
```

# 路由预加载，在用户真正进入路由之前，把 JS 先下载好

- lazy + preload

```js
import React from "react";
export function lazyWithPreload(factory) {
  const Component = React.lazy(factory);
  Component.preload = factory;
  return Component;
}
路由文件里面;
import { lazyWithPreload } from "./lazyWithPreload";
const Home = lazyWithPreload(() => import("./pages/Home"));
```

# 数据预加载，比如接口什么的

- HTML 层尽早发请求（最早时机）<link rel="preload" href="/api/home/data" as="fetch" crossorigin>
- JS 层全局预加载
- 入口文件最早触发，在 main.js 中就触发
- 目标页面直接使用缓存 Promise

# webpack 预加载（魔法注释）不要大量用

- preload = 当前页面马上用 优先级更高适合首屏资源 - 不阻塞渲染
- prefetch = 下一页面可能用 下一个页面可能会用到的资源 - 比如路由页面的 js/图片。- 不阻塞渲染
- webpackChunkName: "user" 会自动分包
- 注意点：还是要把大库拆出来，分包
  ## 生效的前提
  - 你在用 Webpack 4+
  - 使用了 HtmlWebpackPlugin
  ## 使用方法
  ```js
  import(/* webpackPreload: true */ "./components/Chart");
  ```

# quickline 等工具

# React Query - 服务端状态（接口数据）

React Query 是 React 的“数据操作系统”，它让你彻底摆脱 useEffect + useState + loading + error 的地狱

```js
- 接口缓存
- 自动刷新
- 状态同步
- 失效重拉
- 并发去重
- loading/error 管理
```

# 服务端渲染 ssr
