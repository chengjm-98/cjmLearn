# 什么是大文件的分块流式加载

就是将一个大的文件对象进行切片，然后并发下载分片，为防止并发请求过多，可以采用**线程池**进行并发控制，最后再进行组装合并。另外还有**断点续传**支持

# 实现基础

- http 的 range 请求
- 如果服务器支持，会返回**206**状态码，同时返回 Content-Range 头信息
- 假如所请求的范围不合法，那么服务器会返回 **416** Range Not

## range 的用法

- unit：范围请求所采用的单位，通常是字节（bytes）。
- <range-start>：一个整数，表示在特定单位下，范围的起始值。
- <range-end>：一个整数，表示在特定单位下，范围的结束值。这个值是可选的，如果不存在，表示此范围一直延伸到文档结束。

## 关键思路

### 1. 分块

- 发送 HEAD 请求，只获取响应头信息，获取文件大小和是否支持分片
- 拆分分片，计算出分片大小，根据分片大小计算出分片数量
- 创建本地数据库 dbindex
  - 使用 indexedDB.open("downloadDB", 1) 打开数据库
  - onupgradeneeded 创建对象仓库（表） chunks

### 2. 并发

- parallelDownload(url, chunks, signal)
  - 使用 AbortController 可以中断请求
  - 使用 Worker Pool 模型，开启多个线程，并发下载分片。可以设定并发数量。
  - 每个 worker 是一个 async 函数，内部有 while 循环：
    - 循环取队列任务
    - 下载分片
    - 保存缓存
    - 更新进度
  - 下载的时候，也可以加个回调函数，梅西下载完一个分片就可以进行操作，比如渲染什么的

### 3. 合并

- 合并分片
  - 读取 dbindex，获取分片信息
  - 读取分片，合并
  - 生成 blob const fileBlob = new Blob(results);
  - 生成 url const fileUrl = URL.createObjectURL(fileBlob);
  - 生成 a 标签，触发下载
    - const a = document.createElement("a");
    - a.href = fileUrl;
    - a.download = "downloaded_file";

### 4. 缓存

- 使用 indexbd 进行缓存，缓存已经下载的分片信息
- 为什么要使用indexbd？
- 真正断点续传/你关浏览器再打开/下载进度还在已经下载的分片还在直接从断点继续
- 储存空间大/浏览器关闭/刷新也不会丢失数据

### 5. 断点续传

- 断点续传能实现的原因
- indexdb 存储了下载的分片信息
- 使用 AbortController 可以中断请求
