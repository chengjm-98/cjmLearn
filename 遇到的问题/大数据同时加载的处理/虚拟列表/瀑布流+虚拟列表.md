# 背

-我实现了一套 基于绝对定位的瀑布流虚拟列表，通过预估高度先计算布局，滚动时只渲染可视区元素，图片加载完成后对同列元素进行高度回溯修正，并结合 IntersectionObserver 实现图片懒加载，同时支持无限滚动。

## 整体思路

# 为什么瀑布流不能直接用普通虚拟列表？

因为瀑布流 item 高度不固定，item 的 top 不是 index × height，
所以我把问题拆成两步：
先算布局（数据层），再做虚拟渲染（视图层）。

# 数据和布局是如何解耦的？

我维护了两个核心结构：

- data：纯业务数据
- positions：每个 item 的布局信息（top、left、width、height、col）
- 虚拟列表只关心 positions，而不是 data，这样滚动裁剪逻辑非常清晰。

# 瀑布流是怎么实现的

我用的是经典的 最短列算法：用一个 columnHeights 数组记录每一列当前高度，每次新增 item 时，找到高度最小的列把 item 放到该列的底部这样可以保证整体视觉上的均衡。

# 预估高度为什么必要

因为图片在加载完成前是拿不到真实高度的，如果不先用一个预估高度占位，就没法计算后续 item 的位置，也没法实现虚拟滚动。

## 虚拟滚动是如何做的

## 整体优化

- 虚拟列表：避免 DOM 数量过多
- 增量布局计算：只计算新增数据
- IntersectionObserver：减少无效图片加载
- useRef 存储计算状态：避免无意义的 re-render
- buffer 区间：防止快速滚动白屏
- 滚动监听可以用 requestAnimationFrame 再做一次节流。
