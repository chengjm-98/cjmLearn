# 整体的一个错误监控，不深入业务代码

| 错误类型             | 捕获方式                                                | 说明                                 |
| -------------------- | ------------------------------------------------------- | ------------------------------------ |
| JS 运行时错误        | `window.onerror`                                        | 捕获语法错误、引用错误、未捕获异常等 |
| Promise 异常         | `window.onunhandledrejection`                           | 捕获未被 `catch` 的 Promise reject   |
| 资源加载失败         | `window.addEventListener('error', fn, true)`            | 捕获 img/script/link 等资源加载失败  |
| Vue/React 框架错误   | Vue: `app.config.errorHandler` <br>React: ErrorBoundary | 捕获组件渲染错误                     |
| 网络请求失败         | 封装 fetch/axios                                        | 捕获接口请求失败或超时               |
| 用户行为埋点（可选） | 自定义函数                                              | 捕获用户操作路径，便于复现问题       |

## qiankun 的错误监控

- addErrorHandler / removeErrorHandler ---- qiankun 暴露的全局错误订阅接口：
- 可以监听子应用入口加载失败/生命周期执行异常（bootstrap / mount / unmount）/JS 运行错误/资源加载失败/沙箱异常/promise 异常/资源 404
- 为什么不用 window.onerror ？
  - 没办法区分具体是哪个子应用的错误

## 核心思路

- 核心思路是尽量在全局捕获错误，不依赖业务代码在每处 try/catch。
- 最终可以通过接口统一上报，然后提醒。
- 然后在项目入口比如 main.ts 或者 index.tsx 中引用

## 具体实现

```jsx
 // errorMonitor.ts
interface ErrorReport {
  type: string;           // 错误类型
  message: string;        // 错误信息
  filename?: string;      // JS 文件名
  lineno?: number;        // 行号
  colno?: number;         // 列号
  stack?: string;         // 堆栈
  url?: string;           // 页面url
  userAgent?: string;     // 浏览器信息
  timestamp?: number;     // 时间戳
}

function sendError(report: ErrorReport) {
  // 统一上报到后端
  navigator.sendBeacon('/api/log/client-error', JSON.stringify(report));
}

export function initErrorMonitor() {
  // 1. JS 运行时错误
  window.onerror = function(message, source, lineno, colno, error) {
    sendError({
      type: 'js_error',
      message: message as string,
      filename: source as string,
      lineno,
      colno,
      stack: error?.stack,
      url: location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    });
    return false; // 保留浏览器默认错误提示，可设为 true 阻止控制台报错
  };

  // 2. Promise 未捕获异常
  window.onunhandledrejection = function(event) {
    const error = event.reason;
    sendError({
      type: 'promise_error',
      message: error?.message || String(error),
      stack: error?.stack,
      url: location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    });
  };

  // 3. 资源加载错误
  window.addEventListener('error', function(event) {
    const target = event.target as HTMLScriptElement | HTMLLinkElement | HTMLImageElement;
    if (target && (target.tagName === 'IMG' || target.tagName === 'SCRIPT' || target.tagName === 'LINK')) {
      sendError({
        type: 'resource_error',
        message: `Resource failed to load: ${target.src || target.href}`,
        url: location.href,
        userAgent: navigator.userAgent,
        timestamp: Date.now()
      });
    }
  }, true);
}
然后在项目入口比如main.ts或者index.tsx中引用
import { initErrorMonitor } from './errorMonitor';

initErrorMonitor();

```

还可以配合 react 的错误边界 Error Boundary

# 一些现成的监控工具

- Sentry 可以集成到 react 项目中等等
