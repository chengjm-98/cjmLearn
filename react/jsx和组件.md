# jsx

## 什么是 jsx？

jsx 是 js 的语法糖，是一种类似于 html 的语法，用来描述 ui 的。（是一种语法扩展）

## 使用注意

1. jsx 必须有且只有一个根元素。
   **为什么**  
   JSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。

## jsx 转换过程

1. babel 会把 jsx 转换为 React.createElement()函数调用。
2. React.createElement()函数会返回一个 React 元素对象（虚拟 dom）。
3. React 元素对象(虚拟 dom)会被 ReactDOM.render()函数渲染到页面上。

# 组件

## 组件的分类

React 组件必须以大写字母开头。

1. 函数组件
   React 组件是一段可以 使用标签进行扩展 的 JavaScript 函数。
2. 类组件

## 区别

# 纯函数和副作用

## 纯函数

1. 相同的输入，永远会得到相同的输出。
2. 函数的执行过程中，不会产生任何副作用。
3. 函数的执行过程中，不会改变任何外部变量的值。
4. 函数的执行过程中，不会调用任何外部函数。

**对于 react 组件来说：**  
也就是说，对于相同的输入，你所编写的 React 组件必须总是返回相同的 JSX。

## 副作用（（不符合）预期的后果 ）

React 的渲染过程必须自始至终是纯粹的。组件应该只 返回 它们的 JSX，而不 改变 在渲染前，就已存在的任何对象或变量 — 这将会使它们变得不纯粹！

有副作用的函数组件：

```jsx
let guest = 0;

function Cup() {
  // Bad：正在更改预先存在的变量！
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

**展示的结果**

```jsx
Tea cup for guest #2
Tea cup for guest #4

Tea cup for guest #6
```

**原因：**  
该组件正在读写其外部声明的 guest 变量。这意味着 多次调用这个组件会产生不同的 JSX！并且，如果 其他 组件读取 guest ，它们也会产生不同的 JSX，其结果取决于它们何时被渲染！这是无法预测的。（受其他组件影响）

**react 严格模式**
React 提供了 “严格模式”，在严格模式下开发时，它将会调用每个组件函数两次。通过重复调用组件函数，严格模式有助于找到违反这些规则的组件。

我们注意到，原始示例显示的是 “Guest #2”、“Guest #4” 和 “Guest #6”，而不是 “Guest #1”、“Guest #2” 和 “Guest #3”。原来的函数并不纯粹，因此调用它两次就出现了问题。但对于修复后的纯函数版本，即使调用该函数两次也能得到正确结果。纯函数仅仅执行计算，因此调用它们两次不会改变任何东西 — 就像两次调用 double(2) 并不会改变返回值，两次求解 y = 2x 不会改变 y 的值一样。相同的输入，总是返回相同的输出。

**严格模式在生产环境下不生效**，因此它不会降低应用程序的速度。如需引入严格模式，你可以用 <React.StrictMode> 包裹根组件。一些框架会默认这样做。
