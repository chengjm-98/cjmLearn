# jsx

## 什么是 jsx？

jsx 是 js 的语法糖，是一种类似于 html 的语法，用来描述 ui 的。（是一种语法扩展）

## 使用注意

1. jsx 必须有且只有一个根元素。  
   **为什么**  
   JSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。

## jsx 转换过程

1. babel 会把 jsx 转换为 React.createElement()函数调用。
2. React.createElement()函数会返回一个 React 元素对象（虚拟 dom）。
3. React 元素对象(虚拟 dom)会被 ReactDOM.render()函数渲染到页面上。

# 组件

## 组件的分类

React 组件必须以大写字母开头。

1. 函数组件
   React 组件是一段可以 使用标签进行扩展 的 JavaScript 函数。
2. 类组件

## 区别

# 纯函数和副作用

## 纯函数

1. 相同的输入，永远会得到相同的输出。
2. 函数的执行过程中，不会产生任何副作用。
3. 函数的执行过程中，不会改变任何外部变量的值。
4. 函数的执行过程中，不会调用任何外部函数。

**对于 react 组件来说：**  
最好是纯函数

1.只负责自己的任务，它不会更改在该函数（组件）调用前就已经存在的对象和变量  
2.输入相同，输出相同，组件回返回相同的 JSX

**为什么要使用纯函数**  
1.简洁可预测性：纯函数的输出只取决于输入，这使得代码更易于理解和测试。

2.可缓存性：由于纯函数的输出只取决于输入，所以可以缓存它们的结果，从而提高性能。

3.易于并行化：由于纯函数的输出只取决于输入，所以可以并行执行它们，从而提高性能。

**应该怎么做**  
1.不要直接修改传入的参数，而是创建一个新的对象或变量来存储结果。

## 副作用（（不符合）预期的后果 ）

有副作用的函数组件：

```jsx
let guest = 0;

function Cup() {
  // Bad：正在更改预先存在的变量！
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

**展示的结果**

```jsx
Tea cup for guest #2
Tea cup for guest #4
Tea cup for guest #6
```

**原因：**  
该组件正在读写其外部声明的 guest 变量。这意味着 多次调用这个组件会产生不同的 JSX！并且，如果 其他 组件读取 guest ，它们也会产生不同的 JSX，其结果取决于它们何时被渲染！这是无法预测的。（受其他组件影响）

**改进一下：**

```jsx
function Cup({ i }) {
  return <h2>Tea cup for guest #{i}</h2>;
}
export default function TeaSet() {
  let cups = [];
  for (let i = 1; i <= 3; i++) {
    cups.push(<Cup key={i} i={i} />);
  }
  return cups;
}
```

**react 严格模式**
React 提供了 “严格模式”，在严格模式下开发时，它将会调用每个组件函数两次。通过重复调用组件函数，严格模式有助于找到违反这些规则的组件。

我们注意到，原始示例显示的是 “Guest #2”、“Guest #4” 和 “Guest #6”，而不是 “Guest #1”、“Guest #2” 和 “Guest #3”。原来的函数并不纯粹，因此调用它两次就出现了问题。但对于修复后的纯函数版本，即使调用该函数两次也能得到正确结果。纯函数仅仅执行计算，因此调用它们两次不会改变任何东西 — 就像两次调用 double(2) 并不会改变返回值，两次求解 y = 2x 不会改变 y 的值一样。相同的输入，总是返回相同的输出。

**严格模式在生产环境下不生效**，因此它不会降低应用程序的速度。如需引入严格模式，你可以用 <React.StrictMode> 包裹根组件。一些框架会默认这样做。

**React 组件的副作用：**  
比如：

- 读取外部变量，修改外部变量
- 调用外部函数
- 网络请求
- 定时器
- 直接操作 dom 等

虽然 react 组件中有时候会有一些副作用，但是**React 的渲染过程必须自始至终是纯粹的**
那么怎样保证 React 的渲染过程是纯粹的呢？

1.不改变外部变量的值，比如 props，如果必须要修改最好自己新建一个 state 存储。

2.避免修改直接操作 dom。

3.尽量避免副作用，如果有需要写在特定的地方，渲染逻辑应该是纯粹的。

**如果组件功能和需求必须有副作用，那么应该在哪里写副作用呢？**

1.事件处理程序（比如点击事件等）不需要是纯函数。-------因为即使他们是在你组件内部定义的，他们也不会在渲染期间运行，所以不需要是纯函数。  
2.useEffect() 钩子也不需要是纯函数。-------因为即使他们是在你组件内部定义的，他们也不会在渲染期间运行，所以不需要是纯函数。

# mobx 和副作用

对于 mobx 这种状态管理工具来说，如果你在组件中直接修改了状态，那么就会破坏组件渲染的纯粹性。因为会引入副作用，导致一些不可控的问题。

**解决办法：**

1.使用 mobx 的 action 装饰器来修饰你的组件方法，这样就可以保证你的组件方法是纯函数。

2.调用 mobx 的 action 也在组件的 事件处理程序 和 useEffect 中调用。
