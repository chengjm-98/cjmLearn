## 从 setState 或者说从一个事件触发开始的流程

- **准备阶段**
  - 1.触发更新（比如 setSate/事件）
  - 2.确定优先级 lane，然后层层冒泡到根 fiber。
  - 3.创建**update**（update 中也有 lane），把这个 update 对象添加到 fiber 的**updateQueue.shared.pending**中。
- **调度阶段**
  - 1.Scheduler 从 root.pendingLanes 中选择最高优先级的 lane。
  - 2.根据这个 lane，选择调度方式
    - 最高/离散/同步优先（比如用户输入，表单交互或者必须要同步的更新）→ 立即或者尽快同步执行。
    - Animation lanes（动画）→ 通常通过 **requestAnimationFrame** 安排回调，确保在“下一帧绘制前”执行。
    - 普通并发 / Transition（低优先） → 用并发回调（**MessageChannel / postMessage / rIC polyfill**）分片（time-slicing）执行。
    - Idle（很低） → 可以交给 **requestIdleCallback**（若可用）或放到后面执行。
  - 3.注册到浏览器
    - 调用 **scheduleCallback(priorityLevel, callback)**（在 React Scheduler 包里）。
    - 里面会用不同浏览器 API 把回调塞到队列中，返回一个 callbackNode。
    - 存在 **root.callbackNode** 上，避免重复注册。
    - **为什么要注册而不是立即跑**
      - 并发模式下，React 想要“可中断”，就必须依赖浏览器的 **event loop**。如果 React 自己直接同步跑完整个 Fiber 树，根本没有机会中断。注册给浏览器 API，可以让 React 的渲染分布到不同的时间片执行；在每个时间片结束时让浏览器插入更高优先级的任务（比如用户输入、动画）；React 自己在回调里检查 shouldYield，决定是否暂停。
- **执行阶段 render(调和)-可中断**
  - beginWork
    - 处理当前的 fiber 节点
      - 如果有根据 updateQueue 中的 update，计算新的 state。把结果存到 fiber.memoizedState 中。
      - 返回下一个要处理的 fiber 节点(child)。
  - beginWork 返回 null，进入 completeWork
    - 构建 dom 节点，计算 flag
    - 标记 effect，生成 effect list。把子节点上的 effect 也收集到父节点的 effect list 中。如果当前 fiber 本身有副作用（Placement/Update/Deletion/Ref），将自身 append 到 effectList。
    - 当完成当前 fiber 节点，会检查 shoudledYield/deadline.timeRemaining()，如果时间片耗尽或者有更优先的任务出现，就中断。
    - 中断后，保存 nextUnitOfWork（当前进度）和 workInProgress 栈，并返回到 Scheduler 安排的下一次回调中执行。
- **render 阶段完成**
- 如果 render 阶段走到“没有更多 work”或者当前优先级的任务完成：
  - React 会把 root.finishedWork 设置好，然后 调用 commitRoot（若是并发模式，可能会同步触发 commit，或 defer 到合适时间，但 commit 一旦开始是同步不可中断的）。
  - 在并发模式下，如果有更高优先级的任务到来，render 阶段可能先暂停、不进行 commit，直到处理高优先任务或合并结果。
- **commit 阶段（不可中断）**

  - 1.遍历 effect list，执行副作用（Placement/Update/Deletion/Ref）。
  - 2.把 workInProgress 树赋值给 current 树。

- **完成清理**
  - commit 完成后，root.pendingLanes 会去除已完成的 lanes。
  - 如果还有未完成的 lanes（其他优先级的更新），Scheduler 会再次安排下一次 performWorkOnRoot 来继续处理（可能跨帧）。

## 一些细节

### 动画（Animation lane）如何特殊处理

- 目标：保证动画帧流畅（≈ 60fps），所以动画相关的更新必须在“合适的时间”执行并尽量在一帧内完成。

- 做法：

  - 动画类更新被分到 Animation lane（优先级高于普通更新，但低于离散交互的最高优先）。
  - Scheduler 通常会使用 requestAnimationFrame 注册回调；rAF 的回调时机是「浏览器要绘制下一帧之前」，能保证在 paint 前完成必要的 DOM 更新。
  - 在 rAF 回调里，React 仍然做 time-slicing：如果一帧时间不足以完成所有调和工作，会在该帧能做的时间内尽量做完关键更新（比如与视觉直接相关的部分），剩下的挂起到下一帧继续。这就需要：精准的时间预算（当前帧还剩多少 ms），
  - 把“视觉关键路径”的更新尽量安排先做（优先级更高）。

- 小结：rAF 提供了“恰当的时机”，React 的调和仍然可以中断/分片，但会把动画类更新优先调度到每帧的时间窗口里。

### 优先级变化与抢占（Preemption）机制

- 新到的更高优先级更新会抢占：例如正在进行一个低优先级的并发渲染（transition），此时用户点击输入，产生高优先级更新，Scheduler 会：
  - 把新的高优先级 lane 写入 root.pendingLanes；
  - 如果当前回调正在运行并且优先级更低，内部 hasHigherPriorityWork() 会返回 true，使 shouldYield() 触发，让当前 render 挂起，转去处理高优先级任务。
  - 过期（Expiration）机制：某些任务如果等待太久会被标记为过期（expired），这会促使 Scheduler 将其同步执行以避免用户可感知的延迟（例如长时间未响应的更新最终被强制执行）。
