# 什么时候组件会重新渲染？

### 1.组件的 props 发生变化

### 2.组件的 state 发生变化

当组件内部通过 setState 方法更新状态时，组件会重新渲染。﻿
在函数组件中，通过 useState hook 更新状态也会触发重新渲染。﻿
React 可能会对多个 setState 操作进行批量处理以优化性能，所以状态的改变不一定会立即导致 render 方法的调用。﻿
React 引入了 批处理（batching）机制，即 React 会将多个 setState() 调用合并成一次更新，以提高性能。

**这里还需要解释一下批处理机制**

todo:批处理机制

**这里提一个问题？**

Q:由于批量处理这个机制，所以假如你想要通过更新 state 来实现组件的强制更新，其实也不可行对吧，因为它不是实时的。

A:React 中调用 setState（或 useState 的更新函数）并不会立即更新组件，也不会立即触发 render，所以它不能用于“立即强制更新”组件。

**解决办法，假如一定要强制更新呢**

React 18 新增的 flushSync（来自 react-dom）

todo:需要深入理解一下

```jsx
import { flushSync } from "react-dom";

flushSync(() => {
  setCount(count + 1); // 会立即同步更新并触发 render
});
```

### 3.组件的父组件重新渲染

**这种情况下，如果想要避免子组件的没必要的渲染，需要使用 React.memo()包裹子组件，或者使用 shouldComponentUpdate()方法进行优化。**

react.memo() 是一个高阶组件，它会对组件进行浅比较，如果 props 没有发生变化，那么组件就不会重新渲染。但是其实 props 本身也是这个比较逻辑
它适用的情况是别的 state 导致父组件重新渲染，但是 props 没有变化的情况。如果没有加 memo，那么子组件也会重新渲染。但是如果加了 memo，那么子组件就不会重新渲染。

### 4.上下文的 Provider 的值发生变化（useContext）

### 5.强制重新渲染（类组件）

\*\*这种情况下，需要使用 forceUpdate()方法进行强制重新渲染。

## 快照
