这两都是 http 缓存，但是他们的缓存策略不同，强缓存和协商缓存

- 通过 HTTP 请求头中的 **Cache-Control**、**Expires**、**ETag** 和 **Last-Modified** 等字段来控制缓存行为。
- 通过控制 axios 或者 fetch 的配置项来控制缓存行为。

# 强缓存

## 强缓存的工作流程：

- 浏览器发起请求，发现缓存有效且未过期。
- 浏览器直接从缓存中读取资源，而不会向服务器发起请求。
- 缓存有效期间，不会向服务器发送任何请求，减少了服务器负担并提高页面加载速度。

## 注意事项

- 强缓存直接缓存资源。

## 适用场景：

- 静态资源&不经常变化的内容
- 具体使用代码

```js
import axios from "axios";

// 发送一个带有缓存控制头的请求
axios
  .get("/your-api-endpoint", {
    headers: {
      "Cache-Control": "max-age=3600", // 缓存1小时
      Expires: new Date(Date.now() + 3600 * 1000).toUTCString(), // 缓存到未来1小时
    },
  })
  .then((response) => {
    console.log("Response:", response.data);
  })
  .catch((error) => {
    console.error("Error:", error);
  });
```

## 一些配置项

- Cache-Control：
  - max-age=<seconds>：指定资源在客户端缓存的最大时间（单位为秒）。例如，max-age=3600 表示缓存资源有效期为 1 小时，之后需要重新请求。
  - public：表示该资源可以被任何中间缓存（例如 CDN、代理服务器）缓存。
  - private：表示该资源只能被用户的浏览器缓存，不能被共享缓存（例如 CDN）缓存。
  - no-cache：不使用缓存，每次请求时都需要向服务器确认资源是否被修改。
  - no-store：完全不缓存，浏览器每次都向服务器请求资源。
  - must-revalidate：当缓存过期时，必须向服务器发起请求，重新验证缓存的有效性。
- Expires：
  - Expires 是 HTTP/1.0 中用于设置缓存过期时间的头部。它指定了一个绝对时间（比如某个具体的日期和时间），表示资源的有效期。例如：Expires: Thu, 01 Dec 2023 16:00:00 GMT。
  - 一旦浏览器缓存资源并且当前时间早于 Expires 的时间，浏览器会直接使用缓存，不会发送请求到服务器。

# 协商缓存

一般已经默认使用了协商缓存，所以不需要什么特别的配置。

## 协商缓存的工作流程：

- 浏览器首次请求资源时，会缓存该资源并记录 Last-Modified 或 ETag。
- 当缓存过期后，浏览器再次发起请求，带上 If-Modified-Since 或 If-None-Match。
- 服务器根据这些值判断资源是否修改：
- 如果未修改，返回 304 Not Modified，浏览器使用缓存。
- 如果修改了，返回新的资源，并更新缓存

## 注意事项

- 协商缓存缓存的是资源的元数据，比如最后修改时间、ETag 等。并在请求时用于与服务器协商。

## 适用场景

- 动态资源：API 请求的响应数据、用户信息等内容，通常会发生变化，因此使用协商缓存来减少不必要的请求。
- 资源频繁变化：适用于内容会根据时间或其他因素不断变化的资源。

## 升级使用

- 在前端使用 协商缓存 时，特别是使用 Axios 发送请求，前端开发人员通常不需要手动设置 Last-Modified 和 ETag 请求头，因为这些是服务器端的缓存机制，服务器会根据它们判断资源是否有变化。不过，Axios 会自动处理这些请求头，并将它们与响应的缓存机制结合。
- 升级使用：配合 axios-cache-adapter

```js
import axios from 'axios';
import CacheAdapter from 'axios-cache-adapter';
// 创建一个缓存适配器实例
const cache = CacheAdapter.setup({
  maxAge: 15 * 60 * 1000, // 设置缓存的最大时间（单位为毫秒）
 exclude: {
   query: true,      // 排除带查询参数的请求
   method: 'post',   // 排除 POST 请求
   url: /\/no-cache/ // 排除特定的 URL 请求
 }
 // 其他配置项...
 // 例如：
 maxSize: 100 // 最大缓存 100 个条目
 store: 'memory' // 默认使用内存缓存，也可以使用其他缓存存储，如 localStorage    缓存存储方式
 // store: window.localStorage // 使用 localStorage 持久化缓存
//-----------------------设置可以自定义缓存存储对象
//   const customStore = {
//   setItem: (key, value) => {
//     // 实现存储方法
//   },
//   getItem: (key) => {
//     // 实现获取缓存方法
//   },
//   removeItem: (key) => {
//     // 实现移除缓存的方法
//   }
// };

// cache: {
//   store: customStore // 使用自定义存储
// }
//还有一些别的配置项目
  clearOnStale: true,       // 过期时清除缓存
    filter: (response) => {
      // 只有状态码为 200 且请求 URL 包含 "example" 才缓存
      return response.status === 200 && response.config.url.includes('example');
    },
    cacheFlag: 'my-cache',    // 缓存标识
    serializer: {
      serialize: (data) => JSON.stringify(data),     // 使用 JSON 序列化
      deserialize: (data) => JSON.parse(data)         // 使用 JSON 反序列化
    }



});
// 创建一个带有缓存适配器的 Axios 实例
const axiosInstance = axios.create({
 adapter: cache.adapter,
})
// 发送带有缓存的请求
axiosInstance.get('/api/data')
 .then(response => {
   console.log('Response:', response.data);
 })
 .catch(error => {
   console.error('Error:', error);
 });
```

## 一些配置项

- If-Modified-Since：
  - 当浏览器发起请求时，会在请求头中包含 If-Modified-Since 字段，其值为上次请求时服务器返回的 Last-Modified 字段的值。
  - 服务器接收到请求后，会检查资源的最后修改时间是否与 If-Modified-Since 中的值一致。
  - 如果一致，说明资源未被修改，服务器会返回 304 Not Modified，浏览器会使用缓存。
  - 如果不一致，说明资源已被修改，服务器会返回新的资源，并在响应头中包含 Last-Modified 字段。
- If-None-Match：
  - 当浏览器发起请求时，会在请求头中包含 If-None-Match 字段，其值为上次请求时服务器返回的 ETag 字段的值。
  - 服务器接收到请求后，会检查资源的 ETag 是否与 If-None-Match 中的值一致。
  - 如果一致，说明资源未被修改，服务器会返回 304 Not Modified，浏览器会使用缓存。
  - 如果不一致，说明资源已被修改，服务器会返回新的资源，并在响应头中包含 ETag 字段。
- Last-Modified：
  - 当服务器返回资源时，会在响应头中包含 Last-Modified 字段，其值为资源的最后修改时间。
  - 浏览器接收到响应后，会将 Last-Modified 字段的值保存起来，用于后续的 If-Modified-Since 字段。
- ETag：
  - 当服务器返回资源时，会在响应头中包含 ETag 字段，其值为资源的唯一标识符。（一般是该文件内容的 hash 值）
  - 浏览器接收到响应后，会将 ETag 字段的值保存起来，用于后续的 If-None-Match 字段。
